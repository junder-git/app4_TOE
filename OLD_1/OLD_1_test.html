<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Button Animation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #444;
            background: #111;
            border-radius: 10px;
            cursor: pointer;
            transition: box-shadow 0.3s ease;
        }
        canvas:hover {
            box-shadow: 0 0 20px rgba(100, 100, 255, 0.3);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="100" height="40"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Canvas sizing properties
        const canvasSize = {
            small: { width: 100, height: 40 },
            large: { width: 600, height: 400 },
            isExpanded: false,
            isAnimating: false
        };
        
        // Button properties
        const button = {
            x: 0,
            y: 0,
            width: 100,
            height: 40,
            text: 'Animate!',
            isPressed: false
        };
        
        // Animation properties
        let animationRunning = false;
        let animationStartTime = 0;
        const circles = [];
        
        // Animation state for scaling
        let scaleAnimation = {
            isRunning: false,
            startTime: 0,
            startSize: { width: 0, height: 0 },
            targetSize: { width: 0, height: 0 },
            duration: 300
        };
        
        // Smooth canvas scaling
        function scaleCanvas(expand) {
            if (canvasSize.isAnimating) return;
            
            canvasSize.isAnimating = true;
            canvasSize.isExpanded = expand;
            
            // Set up animation parameters
            scaleAnimation.isRunning = true;
            scaleAnimation.startTime = performance.now();
            scaleAnimation.startSize = {
                width: canvas.width,
                height: canvas.height
            };
            scaleAnimation.targetSize = expand ? canvasSize.large : canvasSize.small;
            
            // Create circles when expanding
            if (expand) {
                circles.length = 0;
                for (let i = 0; i < 8; i++) {
                    circles.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        radius: 5,
                        angle: (i * Math.PI * 2) / 8,
                        speed: 2 + Math.random() * 2,
                        color: `hsl(${i * 45}, 70%, 60%)`,
                        distance: 0
                    });
                }
            }
        }

        function updateScaleAnimation(timestamp) {
            if (!scaleAnimation.isRunning) return;
            
            const elapsed = timestamp - scaleAnimation.startTime;
            const progress = Math.min(elapsed / scaleAnimation.duration, 1);
            const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            const newWidth = scaleAnimation.startSize.width + 
                (scaleAnimation.targetSize.width - scaleAnimation.startSize.width) * eased;
            const newHeight = scaleAnimation.startSize.height + 
                (scaleAnimation.targetSize.height - scaleAnimation.startSize.height) * eased;
            
            canvas.width = newWidth;
            canvas.height = newHeight;
            
            // Update button position for expanded canvas
            if (canvasSize.isExpanded) {
                button.x = (canvas.width - button.width) / 2;
                button.y = canvas.height - button.height - 20;
            } else {
                button.x = 0;
                button.y = 0;
            }
            
            if (progress >= 1) {
                scaleAnimation.isRunning = false;
                canvasSize.isAnimating = false;
            }
        }
        
        // Draw button
        function drawButton() {
            // Button background
            ctx.fillStyle = button.isPressed ? '#555' : '#666';
            ctx.fillRect(button.x, button.y, button.width, button.height);
            
            // Button border
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2;
            ctx.strokeRect(button.x, button.y, button.width, button.height);
            
            // Button text
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                button.text, 
                button.x + button.width / 2, 
                button.y + button.height / 2
            );
        }
        
        // Draw animated circles
        function drawAnimation(deltaTime) {
            if (!animationRunning) return;
            
            const elapsed = deltaTime - animationStartTime;
            
            circles.forEach((circle, index) => {
                // Update position
                circle.distance += circle.speed;
                circle.x = canvas.width / 2 + Math.cos(circle.angle) * circle.distance;
                circle.y = canvas.height / 2 + Math.sin(circle.angle) * circle.distance;
                
                // Draw circle
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.fillStyle = circle.color;
                ctx.fill();
                
                // Add trailing effect
                ctx.shadowColor = circle.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Stop animation after 3 seconds
            if (elapsed > 3000) {
                animationRunning = false;
                // Scale back down when animation ends if not hovering
                if (canvasSize.isExpanded && !isMouseOver) {
                    scaleCanvas(false);
                }
            }
        }
        
        // Track mouse over state
        let isMouseOver = false;
        
        // Main render loop
        function render(timestamp) {
            // Update scale animation
            updateScaleAnimation(timestamp);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background pattern
            ctx.fillStyle = '#333';
            for (let i = 0; i < canvas.width; i += 20) {
                for (let j = 0; j < canvas.height; j += 20) {
                    if ((i + j) % 40 === 0) {
                        ctx.fillRect(i, j, 1, 1);
                    }
                }
            }
            
            // Draw animation
            drawAnimation(timestamp);
            
            // Draw button on top
            drawButton();
            
            requestAnimationFrame(render);
        }
        
        // Handle hover events for canvas scaling
        canvas.addEventListener('mouseenter', () => {
            isMouseOver = true;
            if (!canvasSize.isExpanded) {
                scaleCanvas(true);
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            isMouseOver = false;
            if (canvasSize.isExpanded && !animationRunning) {
                scaleCanvas(false);
            }
        });
        
        // Handle mouse events
        function isPointInButton(x, y) {
            return x >= button.x && x <= button.x + button.width &&
                   y >= button.y && y <= button.y + button.height;
        }
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (isPointInButton(x, y)) {
                button.isPressed = true;
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (button.isPressed && isPointInButton(x, y)) {
                // Start animation
                animationRunning = true;
                animationStartTime = performance.now();
            }
            
            button.isPressed = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            button.isPressed = false;
        });
        
        // Start the render loop
        requestAnimationFrame(render);
    </script>
</body>
</html>